# 修复购买记录删除功能（UUID 版本）

## 日期

2025-12-23

## 问题描述

删除套餐记录时提示"无效的购买记录ID"

## 问题根源

### 第一次修复（错误的假设）

最初误以为 `record.id` 是 String 类型但 API 期望 int 类型，因此添加了 `int.tryParse` 转换。

### 实际情况

后端 API 已经从 int 类型的 ID 迁移到 UUID（String 类型）：

1. **API 模型定义**：`record.id` 的类型是 `String`（UUID 格式）
2. **删除 API 接口**：`boughtId` 参数类型也是 `String`
3. **更新 API 接口**：`boughtId` 参数类型也是 `String`

因此不需要任何类型转换，直接传递 `record.id` 即可。

## 代码分析

### API 模型（自动生成）

```dart
class WebSubFastapiRoutersApiVLowAdminApiUserBoughtGetUserBoughtResponseResultListData {
  final String id; // ID 是 String 类型（UUID）
// ...
}
```

### API 接口定义（已更新）

```dart
// 删除接口期望 String 类型（UUID）
@DELETE('/api/v2/low_admin_api/user_bought/{bought_id}')
Future<ErrorResponse> deleteUserBoughtApiV2LowAdminApiUserBoughtBoughtIdDelete({
  @Path('bought_id') required String boughtId, // String 类型
});

// 更新接口也期望 String 类型（UUID）
@PUT('/api/v2/low_admin_api/user_bought/{bought_id}')
Future<ErrorResponse> putUserBoughtApiV2LowAdminApiUserBoughtBoughtIdPut({
  @Path('bought_id') required String boughtId, // String 类型
  @Body() required UserBoughtPydantic body,
});
```

## 解决方案

### 错误的代码（第一次修复）

```dart
Future<void> _deleteBoughtRecord(
    WebSubFastapiRoutersApiVLowAdminApiUserBoughtGetUserBoughtResponseResultListData record,) async {
  // ...
  final boughtIdInt = int.tryParse(record.id); // ❌ 错误：UUID 无法解析为 int
  if (boughtIdInt == null) {
    // 显示 "无效的购买记录ID" 错误
    return;
  }

  final result = await _restClient.fallback
      .deleteUserBoughtApiV2LowAdminApiUserBoughtBoughtIdDelete(
    boughtId: boughtIdInt, // ❌ 错误：传递 int 但期望 String
  );
}
```

### 正确的代码（最终修复）

```dart
Future<void> _deleteBoughtRecord(
    WebSubFastapiRoutersApiVLowAdminApiUserBoughtGetUserBoughtResponseResultListData record,) async {
  // ...
  final result = await _restClient.fallback
      .deleteUserBoughtApiV2LowAdminApiUserBoughtBoughtIdDelete(
    boughtId: record.id, // ✅ 正确：直接传递 String UUID
  );
}
```

## 具体修改

### 移除不必要的类型转换

**文件**：`lib/component/bought_records/bought_records_list_component.dart`

移除以下代码：

```dart

final boughtIdInt = int.tryParse(record.id);if (
boughtIdInt == null) {
if (mounted) {
ScaffoldMessenger.of(
context,
).showSnackBar(const SnackBar(content: Text('无效的购买记录ID')));
}
return;
}
```

直接使用 `record.id`（String 类型的 UUID）：

```dart

final result = await
_restClient.fallback
    .deleteUserBoughtApiV2LowAdminApiUserBoughtBoughtIdDelete
(
boughtId
:
record
.
id
, // String UUID
);
```

## 验证

- ✅ 编译无错误
- ✅ 类型匹配：String → String
- ✅ 移除了错误的 int 转换逻辑
- ✅ 与更新接口保持一致（都使用 String UUID）

## 相关文件

- `/lib/component/bought_records/bought_records_list_component.dart`
-
`/lib/api/models/web_sub_fastapi_routers_api_v_low_admin_api_user_bought_get_user_bought_response_result_list_data.dart`
- `/lib/api/fallback/fallback_client.dart`

## 经验教训

1. **API 类型一致性**：后端从 int ID 迁移到 UUID 时，删除和更新接口都已正确更新为 String 类型
2. **避免过早假设**：应该先检查 API 接口的实际定义，而不是假设类型不匹配
3. **UUID 处理**：UUID 是 String 类型，不应尝试解析为 int
4. **自动生成代码**：API 客户端代码是自动生成的，应该信任其类型定义的正确性

## 时间线

- **第一次尝试**：错误地添加 `int.tryParse` 转换，导致 UUID 无法解析
- **第二次修复**：检查 API 定义，发现接口已更新为 String 类型，移除转换逻辑
- **结果**：功能正常工作

