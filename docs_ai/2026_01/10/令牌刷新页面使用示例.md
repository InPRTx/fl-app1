# 令牌刷新页面使用示例

## 基本用法

令牌刷新页面会自动在以下情况触发：

1. **定时器检测到令牌即将过期** - 自动刷新失败时跳转
2. **API 调用时发现令牌过期** - Dio 拦截器处理失败时跳转

大部分情况下，你不需要手动调用，系统会自动处理。

## 高级用法：保存返回路径

如果你希望在某个特定页面刷新令牌后能够返回到该页面，可以在页面初始化时保存当前路径：

### 示例 1: 在 StatefulWidget 中保存路径

```dart
import 'package:auto_route/auto_route.dart';
import 'package:fl_app1/store/service/auth/auth_store.dart';
import 'package:flutter/material.dart';

@RoutePage()
class UserDashboardPage extends StatefulWidget {
  const UserDashboardPage({super.key});

  @override
  State<UserDashboardPage> createState() => _UserDashboardPageState();
}

class _UserDashboardPageState extends State<UserDashboardPage> {
  @override
  void initState() {
    super.initState();

    // 保存当前路径，以便刷新成功后返回
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final currentPath = context.router.currentPath;
      AuthStore().saveCurrentPath(currentPath);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('用户仪表盘')),
      body: Center(
        child: Text('用户页面内容'),
      ),
    );
  }
}
```

### 示例 2: 在包装器中统一保存路径

如果你有多个页面需要保存路径，可以在包装器中统一处理：

```dart
import 'package:auto_route/auto_route.dart';
import 'package:fl_app1/store/service/auth/auth_store.dart';
import 'package:flutter/material.dart';

@RoutePage()
class UserWrapperPage extends StatelessWidget {
  const UserWrapperPage({super.key});

  @override
  Widget build(BuildContext context) {
    // 监听路由变化，自动保存当前路径
    return AutoRouter(
      builder: (context, child) {
        // 保存当前路径
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final currentPath = context.router.currentPath;
          AuthStore().saveCurrentPath(currentPath);
        });

        return child;
      },
    );
  }
}
```

### 示例 3: 在路由观察器中全局保存路径

在 `main.dart` 中添加路由观察器，自动保存所有页面的路径：

```dart
class AppRouteObserver extends AutoRouterObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    super.didPush(route, previousRoute);
    
    // 保存当前路径
    if (route.settings.name != null) {
      AuthStore().saveCurrentPath(route.settings.name!);
    }
  }
  
  @override
  void didPop(Route route, Route? previousRoute) {
    super.didPop(route, previousRoute);
    
    // 恢复之前的路径
    if (previousRoute?.settings.name != null) {
      AuthStore().saveCurrentPath(previousRoute!.settings.name!);
    }
  }
}

// 在 MaterialApp.router 中使用
MaterialApp.router(
  routerDelegate: appRouter.delegate(
    navigatorObservers: () => [AppRouteObserver()],
  ),
  // ...
)
```

## 手动跳转到令牌刷新页面

如果你需要手动触发令牌刷新（例如，添加一个"刷新令牌"按钮），可以这样做：

```dart
import 'package:auto_route/auto_route.dart';
import 'package:fl_app1/router/app_router.gr.dart';
import 'package:flutter/material.dart';

class SettingsPage extends StatelessWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('设置')),
      body: ListView(
        children: [
          ListTile(
            leading: const Icon(Icons.refresh),
            title: const Text('手动刷新令牌'),
            onTap: () {
              // 保存当前路径
              final currentPath = context.router.currentPath;
              
              // 跳转到令牌刷新页面
              context.router.push(
                AuthTokenRefreshRoute(returnPath: currentPath),
              );
            },
          ),
        ],
      ),
    );
  }
}
```

## 直接调用 API 刷新

如果你只想在后台刷新令牌而不跳转页面：

```dart
import 'package:fl_app1/store/service/auth/auth_store.dart';
import 'package:flutter/material.dart';

class MyWidget extends StatelessWidget {
  const MyWidget({super.key});

  Future<void> _refreshToken() async {
    final bool success = await AuthStore().apiRefreshToken(
      skipNavigation: true, // 不自动跳转
    );
    
    if (success) {
      debugPrint('✅ 令牌刷新成功');
    } else {
      debugPrint('❌ 令牌刷新失败');
    }
  }

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: _refreshToken,
      child: const Text('后台刷新令牌'),
    );
  }
}
```

## 注意事项

1. **不要在令牌刷新页面内保存路径**，否则会导致循环跳转
2. **skipNavigation: true** 只应该在你确定不需要跳转时使用
3. 保存的路径会在下次刷新时被使用，所以只需要保存一次
4. 如果不保存路径，刷新成功后会默认跳转到首页 `/`

## 测试用例

### 测试刷新成功流程

```dart
// 1. 打开某个页面
context.router.pushPath
('/user/dashboard
'
);

// 2. 保存路径
AuthStore().saveCurrentPath('/user/dashboard');

// 3. 触发刷新（模拟令牌过期）
await
AuthStore
(
)
.
apiRefreshToken
(
);

// 4. 验证：刷新成功后应该返回 /user/dashboard
```

### 测试刷新失败流程

```dart
// 1. 清除刷新令牌（模拟过期）
await AuthStore
().

logout();

// 2. 触发刷新
await AuthStore
().

apiRefreshToken();

// 3. 验证：应该跳转到登录页 /auth/login
```

### 测试重试功能

```dart
// 1. 断开网络
// 2. 触发刷新，应该跳转到刷新页面
// 3. 在刷新页面点击"重试"
// 4. 连接网络
// 5. 再次点击"重试"，应该刷新成功并返回
```

